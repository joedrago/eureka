// ---------------------------------------------------------------------------
//                   Copyright Joe Drago 2010 - 2011.
//         Distributed under the Boost Software License, Version 1.0.
//            (See accompanying file LICENSE_1_0.txt or copy at
//                  http://www.boost.org/LICENSE_1_0.txt)
// ---------------------------------------------------------------------------

#include "yapCompiler.h"

#include "yapBlock.h"
#include "yapChunk.h"
#include "yapCode.h"
#include "yapContext.h"
#include "yapFrame.h"
#include "yapLexer.h"
#include "yapOp.h"
#include "yapParser.h"
#include "yapSyntax.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// ---------------------------------------------------------------------------
// Not in yapParser.h because it is autogenerated
void *yapParseAlloc(struct yapContext *Y);
void yapParse(void *yyp, int id, yapToken token, yapCompiler *compiler);
void yapParseFree(struct yapContext *Y, void *p);
void yapParseTrace(FILE *TraceFILE, char *zTracePrompt);
// ---------------------------------------------------------------------------

void yapCompileOptimize(struct yapContext *Y, yapCompiler *compiler);

yBool yapAssemble(struct yapContext *Y, yapCompiler *compiler);

yapCompiler *yapCompilerCreate(struct yapContext *Y)
{
    yapCompiler *compiler = (yapCompiler *)yapAlloc(sizeof(yapCompiler));
    compiler->Y = Y;
    return compiler;
}

void yapCompilerDestroy(yapCompiler *compiler)
{
    struct yapContext *Y = compiler->Y;
    if(compiler->chunk)
    {
        yapChunkDestroy(Y, compiler->chunk);
    }
    if(compiler->root)
    {
        yapSyntaxDestroy(Y, compiler->root);
    }
    yapArrayClear(Y, &compiler->errors, (yapDestroyCB)yapDestroyCBFree);
    yapFree(compiler);
}

yBool yapCompile(yapCompiler *compiler, const char *text, yU32 compileOpts)
{
    struct yapContext *Y = compiler->Y;
    yBool success = yFalse;
    yapToken emptyToken = {0};
    void *parser;

#ifdef YAP_TRACE_PARSER
    yapParseTrace(stderr, "--- ");
#endif

    yapTraceMem(("\n                                     "
                 "--- start chunk compile ---\n"));

    parser = yapParseAlloc(Y);
    compiler->root = NULL;

    yapLex(parser, text, yapParse, compiler);
    yapParse(parser, 0, emptyToken, compiler);

    if(compiler->root)
    {
        if(!compiler->errors.count)
        {
            if(compileOpts & YCO_OPTIMIZE)
            {
                yapCompileOptimize(Y, compiler);
            }

            yapAssemble(Y, compiler);
            success = yTrue;
        }
        if(!(compileOpts & YCO_KEEP_SYNTAX_TREE))
        {
            yapSyntaxDestroy(Y, compiler->root);
            compiler->root = NULL;
        };
    }
    else
    {
        yapContextSetError(Y, YVE_COMPILE, "unknown badness - grammar is probably incomplete");
    }

    yapParseFree(Y, parser);

    yapTraceMem(("                                     "
                 "---  end  chunk compile ---\n\n"));

    return success;
}

void yapCompileError(yapCompiler *compiler, const char *error)
{
    struct yapContext *Y = compiler->Y;
    yapArrayPush(Y, &compiler->errors, yapStrdup(Y, error));
}

static void appendInt(char *text, int i)
{
    char temp[32];
    sprintf(temp, "%d", i);
    strcat(text, temp);
}

void yapCompileSyntaxError(yapCompiler *compiler, struct yapToken *token)
{
    yapContext *Y = compiler->Y;
    char error[64];
    strcpy(error, "Line [");
    appendInt(error, token->line);
    strcat(error, "]: ");
    strcat(error, "syntax error near '");
    if(token && token->text)
    {
        char *newlinePos;
        char temp[32];
        int len = strlen(token->text);
        if(len > 31) { len = 31; }
        memcpy(temp, token->text, len);
        temp[len] = 0;
        newlinePos = strchr(temp, '\r');
        if(!newlinePos)
        {
            newlinePos = strchr(temp, '\n');
        }
        if(newlinePos)
        {
            *newlinePos = 0;
        }
        strcat(error, temp);
    }
    else
    {
        strcat(error, "<unknown>");
    }
    strcat(error, "'");

    yapCompileError(compiler, error);
}

// ---------------------------------------------------------------------------

static int yapCompileOptimizeChild(struct yapContext *Y, yapCompiler *compiler, yapSyntax *syntax);

static void yapCompileOptimizeArray(struct yapContext *Y, yapCompiler *compiler, yapArray *a)
{
    int i;
    for(i = 0; i < a->count; i++)
    {
        yapCompileOptimizeChild(Y, compiler, (yapSyntax *)a->data[i]);
    }
}

static int yapCompileOptimizeChild(struct yapContext *Y, yapCompiler *compiler, yapSyntax *syntax)
{
    if(syntax->v.a) { yapCompileOptimizeArray(Y, compiler, syntax->v.a); }
    if(syntax->v.p) { yapCompileOptimizeChild(Y, compiler, syntax->v.p); }
    if(syntax->l.a) { yapCompileOptimizeArray(Y, compiler, syntax->l.a); }
    if(syntax->l.p) { yapCompileOptimizeChild(Y, compiler, syntax->l.p); }
    if(syntax->r.a) { yapCompileOptimizeArray(Y, compiler, syntax->r.a); }
    if(syntax->r.p) { yapCompileOptimizeChild(Y, compiler, syntax->r.p); }

    switch(syntax->type)
    {
        case YST_ADD:
        case YST_SUB:
        case YST_MUL:
        case YST_DIV:
        {
            // Integer arithmetic optimization
            if((syntax->l.p->type == YST_KINT)
               && (syntax->r.p->type == YST_KINT))
            {
                int val;
                switch(syntax->type)
                {
                    case YST_ADD:
                        val = syntax->l.p->v.i + syntax->r.p->v.i;
                        break;
                    case YST_SUB:
                        val = syntax->l.p->v.i - syntax->r.p->v.i;
                        break;
                    case YST_MUL:
                        val = syntax->l.p->v.i * syntax->r.p->v.i;
                        break;
                    case YST_DIV:
                        if(!syntax->r.p->v.i) { return 0; }
                        val = syntax->l.p->v.i / syntax->r.p->v.i;
                        break;
                };
                yapSyntaxDestroy(Y, syntax->l.p);
                syntax->l.p = NULL;
                yapSyntaxDestroy(Y, syntax->r.p);
                syntax->r.p = NULL;
                syntax->type = YST_KINT;
                syntax->v.i = val;
            }
        }
        break;
    };

    return 0;
}

void yapCompileOptimize(struct yapContext *Y, yapCompiler *compiler)
{
    yapCompileOptimizeChild(Y, compiler, compiler->root);
}

// ---------------------------------------------------------------------------

enum
{
    ASM_NORMAL = 0,
    ASM_LVALUE = (1 << 0),
    ASM_VAR    = (1 << 1),
    ASM_SETVAR = (1 << 2)
};

#define asmFunc(NAME) \
    yS32 yapAssemble ## NAME (struct yapContext *Y, yapCompiler *compiler, yapCode *dst, yapSyntax *syntax, yS32 keep, yU32 flags)
typedef yS32(*yapAssembleFunc)(struct yapContext *Y, yapCompiler *compiler, yapCode *dst, yapSyntax *syntax, yS32 keep, yU32 flags);

typedef struct yapAssembleInfo
{
    yapAssembleFunc assemble;
} yapAssembleInfo;

asmFunc(Nop);
asmFunc(KString);
asmFunc(KInt);
asmFunc(KFloat);
asmFunc(Identifier);
asmFunc(Index);
asmFunc(StatementExpr);
asmFunc(StatementList);
asmFunc(ExpressionList);
asmFunc(IdentifierList);
asmFunc(Call);
asmFunc(Null);
asmFunc(This);
asmFunc(StringFormat);
asmFunc(Unary);
asmFunc(Binary);
asmFunc(ShortCircuit);
asmFunc(Var);
asmFunc(Break);
asmFunc(Return);
asmFunc(Assignment);
asmFunc(Inherits);
asmFunc(IfElse);
asmFunc(While);
asmFunc(For);
asmFunc(Function);
asmFunc(FunctionArgs);
asmFunc(With);
asmFunc(Scope);

static yapAssembleInfo asmDispatch[YST_COUNT] =
{
    { yapAssembleNop },             // YST_NOP

    { yapAssembleKString },         // YST_KSTRING
    { yapAssembleKInt },            // YST_KINT
    { yapAssembleKFloat },          // YST_KFLOAT
    { yapAssembleIdentifier },      // YST_IDENTIFIER

    { yapAssembleIndex },           // YST_INDEX

    { yapAssembleStatementList },   // YST_STATEMENTLIST
    { yapAssembleExpressionList },  // YST_EXPRESSIONLIST
    { yapAssembleIdentifierList },  // YST_IDENTIFIERLIST

    { yapAssembleCall },            // YST_CALL
    { yapAssembleStringFormat },    // YST_STRINGFORMAT

    { yapAssembleNull },            // YST_NULL
    { yapAssembleThis },            // YST_THIS

    { yapAssembleUnary },           // YST_NOT

    { yapAssembleUnary },           // YST_BITWISE_NOT
    { yapAssembleBinary },          // YST_BITWISE_XOR
    { yapAssembleBinary },          // YST_BITWISE_AND
    { yapAssembleBinary },          // YST_BITWISE_OR
    { yapAssembleBinary },          // YST_SHIFTLEFT
    { yapAssembleBinary },          // YST_SHIFTRIGHT

    { yapAssembleBinary },          // YST_ADD
    { yapAssembleBinary },          // YST_SUB
    { yapAssembleBinary },          // YST_MUL
    { yapAssembleBinary },          // YST_DIV

    { yapAssembleShortCircuit },    // YST_AND
    { yapAssembleShortCircuit },    // YST_OR

    { yapAssembleBinary },          // YST_CMP
    { yapAssembleBinary },          // YST_EQUALS
    { yapAssembleBinary },          // YST_NOTEQUALS
    { yapAssembleBinary },          // YST_GREATERTHAN
    { yapAssembleBinary },          // YST_GREATERTHANOREQUAL
    { yapAssembleBinary },          // YST_LESSTHAN
    { yapAssembleBinary },          // YST_LESSTHANOREQUAL

    { yapAssembleStatementExpr },   // YST_STATEMENT_EXPR
    { yapAssembleAssignment },      // YST_ASSIGNMENT
    { yapAssembleInherits },        // YST_INHERITS
    { yapAssembleVar },             // YST_VAR
    { yapAssembleBreak },           // YST_BREAK
    { yapAssembleReturn },          // YST_RETURN

    { yapAssembleIfElse },          // YST_IFELSE
    { yapAssembleWhile },           // YST_WHILE
    { yapAssembleFor },             // YST_FOR
    { yapAssembleFunction },        // YST_FUNCTION
    { yapAssembleFunctionArgs },    // YST_FUNCTION_ARGS
    { yapAssembleScope },           // YST_SCOPE
};

// This function ensures that what we're being asked to keep is what we offered
int asmPad(struct yapContext *Y, yapCode *code, int keep, int offer, int line)
{
    if(keep == YAV_ALL_ARGS)
    {
        keep = offer;
    }
    else
    {
        if(offer > keep)
        {
            yapCodeGrow(Y, code, 1);
            yapCodeAppend(Y, code, YOP_POP, (yOperand)(offer - keep), line);
        }
        else if(offer < keep)
        {
            int i;
            int nulls = keep - offer;
            yapCodeGrow(Y, code, nulls);
            for(i = 0; i < nulls; i++)
            {
                yapCodeAppend(Y, code, YOP_PUSHNULL, 0, line);
            }
        }
    }
    return keep;
}

#define PAD(OFFER) asmPad(Y, dst, keep, OFFER, syntax->line)

asmFunc(Nop)
{
    printf("NOP detected: %d\n", syntax->type);
    return PAD(0);
}

asmFunc(KString)
{
    yapCodeGrow(Y, dst, 1);
    yapCodeAppend(Y, dst, YOP_PUSH_KS, yapArrayPushUniqueString(Y, &compiler->chunk->kStrings, yapStrdup(Y, syntax->v.s)), syntax->line);
    return PAD(1);
}

asmFunc(KInt)
{
    yapCodeGrow(Y, dst, 1);
    yapCodeAppend(Y, dst, YOP_PUSH_KI, yap32ArrayPushUnique(Y, &compiler->chunk->kInts, &syntax->v.i), syntax->line);
    return PAD(1);
}

asmFunc(KFloat)
{
    yapCodeGrow(Y, dst, 1);
    yapCodeAppend(Y, dst, YOP_PUSH_KF, yap32ArrayPushUnique(Y, &compiler->chunk->kFloats, (yU32 *)&syntax->v.f), syntax->line);
    return PAD(1);
}

asmFunc(Identifier)
{
    yOpcode opcode = YOP_VARREF_KS;
    if(flags & ASM_VAR)
    {
        opcode = YOP_VARREG_KS;
    }
    yapCodeGrow(Y, dst, 1);
    yapCodeAppend(Y, dst, opcode, yapArrayPushUniqueString(Y, &compiler->chunk->kStrings, yapStrdup(Y, syntax->v.s)), syntax->line);
    if(!(flags & ASM_LVALUE))
    {
        yapCodeGrow(Y, dst, 1);
        yapCodeAppend(Y, dst, YOP_REFVAL, 0, syntax->line);
    }
    return PAD(1);
}

asmFunc(Index)
{
    yS32 offerCount = 1;
    yOperand opFlags = 0;
    yBool pushThis = (syntax->v.i) ? yTrue : yFalse;
    yapSyntax *a = syntax->l.p;
    yapSyntax *b = syntax->r.p;
    asmDispatch[a->type].assemble(Y, compiler, dst, a, 1, ASM_NORMAL);
    asmDispatch[b->type].assemble(Y, compiler, dst, b, 1, ASM_NORMAL);
    if(flags & ASM_LVALUE)
    {
        opFlags |= YOF_LVALUE;
    }
    if(keep > 1)
    {
        opFlags |= (pushThis) ? YOF_PUSHTHIS : YOF_PUSHOBJ;
        offerCount++;
    }
    yapCodeGrow(Y, dst, 1);
    yapCodeAppend(Y, dst, YOP_INDEX, opFlags, syntax->line);
    return PAD(offerCount);
}

asmFunc(IdentifierList)
{
    yapArray *args = syntax->v.a;
    int keepCount = 0;
    int i;

    for(i = args->count - 1; i >= 0; i--)
    {
        yapSyntax *arg = (yapSyntax *)args->data[i];
        keepCount = asmDispatch[arg->type].assemble(Y, compiler, dst, arg, 1, flags);
        yapCodeGrow(Y, dst, 1);
        yapCodeAppend(Y, dst, YOP_SETVAR, 0, syntax->line);
    }
    return PAD(args->count);
}

asmFunc(Call)
{
    yapSyntax *func = syntax->v.p;
    yapSyntax *args = syntax->r.p;
    int argCount;

    argCount = asmDispatch[args->type].assemble(Y, compiler, dst, args, YAV_ALL_ARGS, ASM_NORMAL);

    asmDispatch[func->type].assemble(Y, compiler, dst, func, 2, ASM_NORMAL); // requesting 2 to receive 'this' (even if padded with null)

    yapCodeGrow(Y, dst, 2);
    yapCodeAppend(Y, dst, YOP_CALL, argCount, syntax->line);
    yapCodeAppend(Y, dst, YOP_KEEP, keep, syntax->line);
    return PAD(keep);
}

asmFunc(Null)
{
    yapCodeGrow(Y, dst, 1);
    yapCodeAppend(Y, dst, YOP_PUSHNULL, 0, syntax->line);
    return PAD(1);
}

asmFunc(This)
{
    yapCodeGrow(Y, dst, 1);
    yapCodeAppend(Y, dst, YOP_PUSHTHIS, 0, syntax->line);
    return PAD(1);
}

asmFunc(StringFormat)
{
    yapSyntax *format = syntax->l.p;
    yapSyntax *args   = syntax->r.p;
    int argCount = asmDispatch[args->type].assemble(Y, compiler, dst, args, YAV_ALL_ARGS, ASM_NORMAL);
    asmDispatch[format->type].assemble(Y, compiler, dst, format, 1, ASM_NORMAL);
    yapCodeGrow(Y, dst, 1);
    yapCodeAppend(Y, dst, YOP_FORMAT, argCount, syntax->line);
    return PAD(1);
}

asmFunc(Unary)
{
    yapSyntax *expr = syntax->v.p;
    asmDispatch[expr->type].assemble(Y, compiler, dst, expr, 1, ASM_NORMAL);
    yapCodeGrow(Y, dst, 1);
    switch(syntax->type)
    {
        case YST_NOT:
            yapCodeAppend(Y, dst, YOP_NOT, 0, syntax->line);
            break;
        case YST_BITWISE_NOT:
            yapCodeAppend(Y, dst, YOP_BITWISE_NOT, 0, syntax->line);
            break;
    };
    return PAD(1);
}

asmFunc(Binary)
{
    yapSyntax *a = syntax->l.p;
    yapSyntax *b = syntax->r.p;
    yBool compound = syntax->v.i;
    int op = YOP_NOP;
    int aflags = ASM_NORMAL;

    if(compound)
    {
        aflags = ASM_LVALUE;
    }

    asmDispatch[a->type].assemble(Y, compiler, dst, a, 1, aflags);
    if(compound)
    {
        yapCodeGrow(Y, dst, 2);
        yapCodeAppend(Y, dst, YOP_DUPE, 0, syntax->line);
        yapCodeAppend(Y, dst, YOP_REFVAL, 0, syntax->line);
    }
    asmDispatch[b->type].assemble(Y, compiler, dst, b, 1, ASM_NORMAL);

    switch(syntax->type)
    {
            // Legal in either compound statements or expressions
        case YST_ADD:
            op = YOP_ADD;
            break;
        case YST_SUB:
            op = YOP_SUB;
            break;
        case YST_MUL:
            op = YOP_MUL;
            break;
        case YST_DIV:
            op = YOP_DIV;
            break;
        case YST_BITWISE_XOR:
            op = YOP_BITWISE_XOR;
            break;
        case YST_BITWISE_AND:
            op = YOP_BITWISE_AND;
            break;
        case YST_BITWISE_OR:
            op = YOP_BITWISE_OR;
            break;
        case YST_SHIFTLEFT:
            op = YOP_SHIFTLEFT;
            break;
        case YST_SHIFTRIGHT:
            op = YOP_SHIFTRIGHT;
            break;

            // Legal in expressions only
        case YST_CMP:
            op = YOP_CMP;
            break;
        case YST_EQUALS:
            op = YOP_EQUALS;
            break;
        case YST_NOTEQUALS:
            op = YOP_NOTEQUALS;
            break;
        case YST_GREATERTHAN:
            op = YOP_GREATERTHAN;
            break;
        case YST_GREATERTHANOREQUAL:
            op = YOP_GREATERTHANOREQUAL;
            break;
        case YST_LESSTHAN:
            op = YOP_LESSTHAN;
            break;
        case YST_LESSTHANOREQUAL:
            op = YOP_LESSTHANOREQUAL;
            break;
    };

    yapCodeGrow(Y, dst, 1);
    yapCodeAppend(Y, dst, op, 0, syntax->line);

    if(compound)
    {
        yapCodeGrow(Y, dst, 2);
        yapCodeAppend(Y, dst, YOP_MOVE, 1, syntax->line);
        yapCodeAppend(Y, dst, YOP_SETVAR, 0, syntax->line);
        return PAD(0);
    }
    return PAD(1);
}

asmFunc(ShortCircuit)
{
    yS32 skipIndex;
    yapSyntax *a = syntax->l.p;
    yapSyntax *b = syntax->r.p;

    // code to add first expression on the stack
    asmDispatch[a->type].assemble(Y, compiler, dst, a, 1, ASM_NORMAL);

    // test stack top's truth and uses the current value instead of the second expression's value
    yapCodeGrow(Y, dst, 1);
    skipIndex = yapCodeAppend(Y, dst, (syntax->type == YST_AND) ? YOP_AND : YOP_OR, 0, syntax->line);

    // code to add second expression on the stack
    asmDispatch[b->type].assemble(Y, compiler, dst, b, 1, ASM_NORMAL);

    // clue in the and/or opcode how far to optionally jump
    dst->ops[skipIndex].operand = dst->count - skipIndex - 1;

    return PAD(1);
}

asmFunc(Var)
{
    yapSyntax *expr = syntax->v.p;
    asmDispatch[expr->type].assemble(Y, compiler, dst, expr, 1, ASM_VAR | ASM_LVALUE);
    return PAD(1);
}

asmFunc(Break)
{
    yapCodeGrow(Y, dst, 1);
    yapCodeAppend(Y, dst, YOP_BREAK, 0, syntax->line);
    return PAD(0);
}

asmFunc(Return)
{
    yapSyntax *expr = syntax->v.p;
    int retCount = asmDispatch[expr->type].assemble(Y, compiler, dst, expr, YAV_ALL_ARGS, ASM_NORMAL);
    yapCodeGrow(Y, dst, 1);
    yapCodeAppend(Y, dst, YOP_RET, retCount, syntax->line);
    return PAD(0);
}

asmFunc(Assignment)
{
    int i;
    yapSyntax *l = syntax->l.p;
    yapSyntax *r = syntax->r.p;
    int leave = (keep > 0) ? 1 : 0;
    yapCode *lvalueCode = yapCodeCreate();
    int lvalueCount = asmDispatch[l->type].assemble(Y, compiler, lvalueCode, l, YAV_ALL_ARGS, ASM_LVALUE|ASM_SETVAR);
    asmDispatch[r->type].assemble(Y, compiler, dst, r, lvalueCount, ASM_NORMAL);
    yapCodeConcat(Y, dst, lvalueCode);
    yapCodeDestroy(Y, lvalueCode);
    if(l->type != YST_EXPRESSIONLIST)
    {
        yapCodeGrow(Y, dst, 1);
        yapCodeAppend(Y, dst, YOP_SETVAR, leave, syntax->line);
    }
    return PAD(leave);
}

asmFunc(Inherits)
{
    yapSyntax *l = syntax->l.p;
    yapSyntax *r = syntax->r.p;

    asmDispatch[r->type].assemble(Y, compiler, dst, r, 1, ASM_NORMAL);
    asmDispatch[l->type].assemble(Y, compiler, dst, l, 1, ASM_NORMAL);
    yapCodeGrow(Y, dst, 1);
    yapCodeAppend(Y, dst, YOP_INHERITS, 0, syntax->line);
    return PAD(1);
}

asmFunc(IfElse)
{
    yapSyntax *cond     = syntax->v.p;
    yapSyntax *ifBody   = syntax->l.p;
    yapSyntax *elseBody = syntax->r.p;
    yapCode *ifCode = yapCodeCreate();
    int index;
    int i;

    if(elseBody)
    {
        yapCode *elseCode = yapCodeCreate();
        asmDispatch[elseBody->type].assemble(Y, compiler, elseCode, elseBody, 0, ASM_NORMAL);
        yapCodeGrow(Y, elseCode, 1);
        yapCodeAppend(Y, elseCode, YOP_LEAVE, 0, syntax->line);
        index = yapBlockConvertCode(Y, elseCode, compiler->chunk, 0);
        yapCodeGrow(Y, dst, 1);
        yapCodeAppend(Y, dst, YOP_PUSH_KB, index, syntax->line);
    }

    asmDispatch[ifBody->type].assemble(Y, compiler, ifCode, ifBody, 0, ASM_NORMAL);
    yapCodeGrow(Y, ifCode, 1);
    yapCodeAppend(Y, ifCode, YOP_LEAVE, 0, syntax->line);
    index = yapBlockConvertCode(Y, ifCode, compiler->chunk, 0);
    yapCodeGrow(Y, dst, 1);
    yapCodeAppend(Y, dst, YOP_PUSH_KB, index, syntax->line);

    // Only keeps the value of the first expression on the stack for bool testing
    asmDispatch[cond->type].assemble(Y, compiler, dst, cond, 1, ASM_NORMAL);

    yapCodeGrow(Y, dst, 1);
    yapCodeAppend(Y, dst, YOP_IF, (elseBody) ? 1 : 0, syntax->line);

    return PAD(0);
}

asmFunc(While)
{
    yapSyntax *cond = syntax->v.p;
    yapSyntax *body = syntax->r.p;
    yapCode   *loop = yapCodeCreate();
    int index;

    yapCodeGrow(Y, loop, 1);
    yapCodeAppend(Y, loop, YOP_START, 0, syntax->line);

    asmDispatch[cond->type].assemble(Y, compiler, loop, cond, 1, ASM_NORMAL);
    yapCodeGrow(Y, loop, 1);
    yapCodeAppend(Y, loop, YOP_LEAVE, 1, syntax->line);

    asmDispatch[body->type].assemble(Y, compiler, loop, body, 0, ASM_NORMAL);

    yapCodeGrow(Y, loop, 1);
    yapCodeAppend(Y, loop, YOP_CONTINUE, 0, syntax->line);

    index = yapBlockConvertCode(Y, loop, compiler->chunk, 0);

    yapCodeGrow(Y, dst, 1);
    yapCodeAppend(Y, dst, YOP_PUSH_KB, index, syntax->line);
    yapCodeGrow(Y, dst, 1);
    yapCodeAppend(Y, dst, YOP_ENTER, YFT_LOOP, syntax->line);

    return PAD(0);
}

asmFunc(For)
{
    yapSyntax *vars = syntax->v.p;
    yapSyntax *iter = syntax->l.p;
    yapSyntax *body = syntax->r.p;
    yapCode   *loop = yapCodeCreate();
    int index;

    // Get the iterable onto the stack
    asmDispatch[iter->type].assemble(Y, compiler, dst, iter, 1, ASM_NORMAL);

    yapCodeGrow(Y, loop, 5);
    yapCodeAppend(Y, loop, YOP_DUPE, 0, syntax->line);    // stash the object itself
    yapCodeAppend(Y, loop, YOP_COUNT, 0, syntax->line);   // using the dupe, call .count(, syntax->line) to push the count on top
    yapCodeAppend(Y, loop, YOP_KEEP, 1, syntax->line);    // keep only one value from the call to .count()
    yapCodeAppend(Y, loop, YOP_PUSHI, 0, syntax->line);   // init our counter to zero
    yapCodeAppend(Y, loop, YOP_CLEANUP, 3, syntax->line); // Mark the 3 'for loop' items as things to clean up

    // At this point, the stack should look like:
    // -- top --
    // counter = 0
    // count = N
    // object

    yapCodeGrow(Y, loop, 3);
    yapCodeAppend(Y, loop, YOP_START, 0, syntax->line);   // begin loop
    yapCodeAppend(Y, loop, YOP_SUB, 1, syntax->line);     // push (count-counter, syntax->line) onto stack
    yapCodeAppend(Y, loop, YOP_LEAVE, 1, syntax->line);   // leave if ((count-counter, syntax->line) == 0)

    // Populate the loop vars from the call to get()
    yapCodeGrow(Y, loop, 7);
    yapCodeAppend(Y, loop, YOP_DUPE, 0, syntax->line);    // dupe counter
    yapCodeAppend(Y, loop, YOP_DUPE, 3, syntax->line);    // dupe object
    yapCodeAppend(Y, loop, YOP_NTH, 0, syntax->line);     // call nth
    yapCodeAppend(Y, loop, YOP_KEEP, vars->v.a->count, syntax->line);
    asmDispatch[vars->type].assemble(Y, compiler, loop, vars, vars->v.a->count, ASM_LVALUE | ASM_VAR);

    // Assemble the loop body itself
    asmDispatch[body->type].assemble(Y, compiler, loop, body, 0, ASM_NORMAL);

    // Increment the counter and loop
    yapCodeGrow(Y, loop, 3);
    yapCodeAppend(Y, loop, YOP_PUSHI, 1, syntax->line);
    yapCodeAppend(Y, loop, YOP_ADD, 0, syntax->line);
    yapCodeAppend(Y, loop, YOP_CONTINUE, 0, syntax->line);

    index = yapBlockConvertCode(Y, loop, compiler->chunk, 0);

    yapCodeGrow(Y, dst, 2);
    yapCodeAppend(Y, dst, YOP_PUSH_KB, index, syntax->line);
    yapCodeAppend(Y, dst, YOP_ENTER, YFT_LOOP, syntax->line);

    return PAD(0);
}

asmFunc(Function)
{
    yapSyntax *args = syntax->l.p;
    yapSyntax *body = syntax->r.p;
    char *name = syntax->v.s;
    yapCode *code = yapCodeCreate();
    yOperand index;

    // If a name is used ("func name()" vs "func()"), the
    // generated code will consume the block left on the stack
    // with a setvar, effectively compiling "func name()" into
    // "var name = func()".
    int additionalOpsForNaming = 0;
    int valuesLeftOnStack = 1;

    int argCount = asmDispatch[args->type].assemble(Y, compiler, code, args, YAV_ALL_ARGS, ASM_VAR | ASM_LVALUE);
    asmDispatch[body->type].assemble(Y, compiler, code, body, 0, ASM_NORMAL);
    yapCodeGrow(Y, code, 1);
    yapCodeAppend(Y, code, YOP_RET, 0, syntax->line);
    index = yapBlockConvertCode(Y, code, compiler->chunk, argCount);

    if(name)
    {
        additionalOpsForNaming = 2;
        valuesLeftOnStack = 0;
    }
    yapCodeGrow(Y, dst, 2 + additionalOpsForNaming);
    yapCodeAppend(Y, dst, YOP_PUSH_KB, index, syntax->line);    // Push the new block on the stack
    yapCodeAppend(Y, dst, YOP_CLOSE, 0, syntax->line);          // Give the VM an opportunity to pepper it with closure data
    if(name)
    {
        yapCodeAppend(Y, dst, YOP_VARREG_KS, yapArrayPushUniqueString(Y, &compiler->chunk->kStrings, yapStrdup(Y, name)), syntax->line);
        yapCodeAppend(Y, dst, YOP_SETVAR, 0, syntax->line);
    };
    compiler->chunk->hasFuncs = yTrue;
    return PAD(valuesLeftOnStack);
}

asmFunc(FunctionArgs)
{
    int argCount;
    int varargsOpIndex = 0;
    yapSyntax *args = syntax->l.p;
    const char *varargsName = syntax->v.s;
    if(varargsName)
    {
        yapCodeGrow(Y, dst, 3);
        varargsOpIndex = yapCodeAppend(Y, dst, YOP_VARARGS, 0, args->line);
        yapCodeAppend(Y, dst, YOP_VARREG_KS, yapArrayPushUniqueString(Y, &compiler->chunk->kStrings, yapStrdup(Y, varargsName)), syntax->line);
        yapCodeAppend(Y, dst, YOP_SETVAR, 0, syntax->line);
    }

    argCount = asmDispatch[args->type].assemble(Y, compiler, dst, args, keep, flags);

    if(varargsName)
    {
        dst->ops[varargsOpIndex].operand = argCount;
        return YAV_ALL_ARGS;
    }
    return argCount;
}

asmFunc(Scope)
{
    yapSyntax *body = syntax->v.p;
    yapCode   *code = yapCodeCreate();
    int index;

    // create new block from "body"
    asmDispatch[body->type].assemble(Y, compiler, code, body, 0, ASM_NORMAL);
    yapCodeGrow(Y, code, 1);
    yapCodeAppend(Y, code, YOP_LEAVE, 0, syntax->line);
    index = yapBlockConvertCode(Y, code, compiler->chunk, 0);

    yapCodeGrow(Y, dst, 1);
    yapCodeAppend(Y, dst, YOP_PUSH_KB, index, syntax->line);
    yapCodeGrow(Y, dst, 1);
    yapCodeAppend(Y, dst, YOP_ENTER, YFT_SCOPE, syntax->line);

    return PAD(0);
}

asmFunc(ExpressionList)
{
    int i = 0;
    int last = syntax->v.a->count;
    int increment = 1;
    int keepCount = 0;
    int reverseOrder = (flags & ASM_SETVAR); // values must be SETVAR'd by popping off the stack in reverse
    for(i = 0; i < syntax->v.a->count; i++)
    {
        int index = (reverseOrder) ? (syntax->v.a->count - 1) - i : i;
        int keepIt = ((keep == YAV_ALL_ARGS) || (i < keep)) ? 1 : 0; // keep one from each expr, dump the rest
        yapSyntax *child = (yapSyntax *)syntax->v.a->data[index];
        keepCount += asmDispatch[child->type].assemble(Y, compiler, dst, child, keepIt, flags & ~ASM_SETVAR);
        if(flags & ASM_SETVAR)
        {
            yapCodeGrow(Y, dst, 1);
            yapCodeAppend(Y, dst, YOP_SETVAR, 0, syntax->line);
        }
    }
    return PAD(keepCount);
}

asmFunc(StatementExpr)
{
    yapSyntax *child = syntax->v.p;
    int keepCount = asmDispatch[child->type].assemble(Y, compiler, dst, child, keep, ASM_NORMAL);
    return PAD(keepCount);
}

asmFunc(StatementList)
{
    int keepCount = 0;
    int i;
    for(i = 0; i < syntax->v.a->count; i++)
    {
        yapSyntax *child = (yapSyntax *)syntax->v.a->data[i];
        keepCount = asmDispatch[child->type].assemble(Y, compiler, dst, child, 0, ASM_NORMAL);
    }
    return PAD(keepCount);
}

yBool yapAssemble(struct yapContext *Y, yapCompiler *compiler)
{
    if(compiler->root && (compiler->root->type == YST_STATEMENTLIST))
    {
        int blockIndex;
        compiler->chunk = yapChunkCreate();
        compiler->code   = yapCodeCreate();
        yapAssembleStatementList(Y, compiler, compiler->code, compiler->root, 0, ASM_NORMAL);
        yapCodeGrow(Y, compiler->code, 1);
        yapCodeAppend(Y, compiler->code, YOP_RET, 0, 0);
        blockIndex = yapBlockConvertCode(Y, compiler->code, compiler->chunk, 0);
        compiler->chunk->block = (yapBlock *)compiler->chunk->blocks.data[blockIndex];
    }
    return yTrue;
}
