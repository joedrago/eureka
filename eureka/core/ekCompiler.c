// ---------------------------------------------------------------------------
//                   Copyright Joe Drago 2010 - 2011.
//         Distributed under the Boost Software License, Version 1.0.
//            (See accompanying file LICENSE_1_0.txt or copy at
//                  http://www.boost.org/LICENSE_1_0.txt)
// ---------------------------------------------------------------------------

#include "ekCompiler.h"

#include "ekBlock.h"
#include "ekChunk.h"
#include "ekCode.h"
#include "ekContext.h"
#include "ekFrame.h"
#include "ekLexer.h"
#include "ekOp.h"
#include "ekParser.h"
#include "ekSyntax.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// ---------------------------------------------------------------------------
// Not in ekParser.h because it is autogenerated
void *ekParseAlloc(struct ekContext *E);
void ekParse(void *yyp, int id, ekToken token, ekCompiler *compiler);
void ekParseFree(struct ekContext *E, void *p);
void ekParseTrace(FILE *TraceFILE, char *zTracePrompt);
// ---------------------------------------------------------------------------

void ekCompileOptimize(struct ekContext *E, ekCompiler *compiler);

ekBool ekAssemble(struct ekContext *E, ekCompiler *compiler);

ekCompiler *ekCompilerCreate(struct ekContext *E)
{
    ekCompiler *compiler = (ekCompiler *)ekAlloc(sizeof(ekCompiler));
    compiler->E = E;
    return compiler;
}

void ekCompilerDestroy(ekCompiler *compiler)
{
    struct ekContext *E = compiler->E;
    if(compiler->chunk)
    {
        ekChunkDestroy(E, compiler->chunk);
    }
    if(compiler->root)
    {
        ekSyntaxDestroy(E, compiler->root);
    }
    ekArrayDestroy(E, &compiler->errors, (ekDestroyCB)ekDestroyCBFree);
    ekFree(compiler);
}

ekBool ekCompile(ekCompiler *compiler, const char *text, ekU32 compileOpts)
{
    struct ekContext *E = compiler->E;
    ekBool success = ekFalse;
    ekToken emptyToken = {0};
    void *parser;

#ifdef EUREKA_TRACE_PARSER
    ekParseTrace(stderr, "--- ");
#endif

    ekTraceMem(("\n                                     "
                "--- start chunk compile ---\n"));

    parser = ekParseAlloc(E);
    compiler->root = NULL;

    ekLex(parser, text, ekParse, compiler);
    ekParse(parser, 0, emptyToken, compiler);

    if(compiler->root)
    {
        if(!ekArraySize(E, &compiler->errors))
        {
            if(compileOpts & YCO_OPTIMIZE)
            {
                ekCompileOptimize(E, compiler);
            }

            ekAssemble(E, compiler);
            success = ekTrue;
        }
        if(!(compileOpts & YCO_KEEP_SYNTAX_TREE))
        {
            ekSyntaxDestroy(E, compiler->root);
            compiler->root = NULL;
        };
    }
    else
    {
        ekContextSetError(E, YVE_COMPILE, "unknown badness - grammar is probably incomplete");
    }

    ekParseFree(E, parser);

    ekTraceMem(("                                     "
                "---  end  chunk compile ---\n\n"));

    return success;
}

void ekCompileError(ekCompiler *compiler, const char *error)
{
    struct ekContext *E = compiler->E;
    ekArrayPush(E, &compiler->errors, ekStrdup(E, error));
}

static void appendInt(char *text, int i)
{
    char temp[32];
    sprintf(temp, "%d", i);
    strcat(text, temp);
}

void ekCompileSyntaxError(ekCompiler *compiler, struct ekToken *token)
{
    ekContext *E = compiler->E;
    char error[64];
    strcpy(error, "Line [");
    appendInt(error, token->line);
    strcat(error, "]: ");
    strcat(error, "syntax error near '");
    if(token && token->text)
    {
        char *newlinePos;
        char temp[32];
        int len = strlen(token->text);
        if(len > 31) { len = 31; }
        memcpy(temp, token->text, len);
        temp[len] = 0;
        newlinePos = strchr(temp, '\r');
        if(!newlinePos)
        {
            newlinePos = strchr(temp, '\n');
        }
        if(newlinePos)
        {
            *newlinePos = 0;
        }
        strcat(error, temp);
    }
    else
    {
        strcat(error, "<unknown>");
    }
    strcat(error, "'");

    ekCompileError(compiler, error);
}

// ---------------------------------------------------------------------------

static int ekCompileOptimizeChild(struct ekContext *E, ekCompiler *compiler, ekSyntax *syntax);

static void ekCompileOptimizeArray(struct ekContext *E, ekCompiler *compiler, ekSyntax **a)
{
    int i;
    for(i = 0; i < ekArraySize(E, &a); i++)
    {
        ekCompileOptimizeChild(E, compiler, (ekSyntax *)a[i]);
    }
}

static int ekCompileOptimizeChild(struct ekContext *E, ekCompiler *compiler, ekSyntax *syntax)
{
    if(syntax->v.a) { ekCompileOptimizeArray(E, compiler, syntax->v.a); }
    if(syntax->v.p) { ekCompileOptimizeChild(E, compiler, syntax->v.p); }
    if(syntax->l.a) { ekCompileOptimizeArray(E, compiler, syntax->l.a); }
    if(syntax->l.p) { ekCompileOptimizeChild(E, compiler, syntax->l.p); }
    if(syntax->r.a) { ekCompileOptimizeArray(E, compiler, syntax->r.a); }
    if(syntax->r.p) { ekCompileOptimizeChild(E, compiler, syntax->r.p); }

    switch(syntax->type)
    {
        case YST_ADD:
        case YST_SUB:
        case YST_MUL:
        case YST_DIV:
        {
            // Integer arithmetic optimization
            if((syntax->l.p->type == YST_KINT)
               && (syntax->r.p->type == YST_KINT))
            {
                int val;
                switch(syntax->type)
                {
                    case YST_ADD:
                        val = syntax->l.p->v.i + syntax->r.p->v.i;
                        break;
                    case YST_SUB:
                        val = syntax->l.p->v.i - syntax->r.p->v.i;
                        break;
                    case YST_MUL:
                        val = syntax->l.p->v.i * syntax->r.p->v.i;
                        break;
                    case YST_DIV:
                        if(!syntax->r.p->v.i) { return 0; }
                        val = syntax->l.p->v.i / syntax->r.p->v.i;
                        break;
                };
                ekSyntaxDestroy(E, syntax->l.p);
                syntax->l.p = NULL;
                ekSyntaxDestroy(E, syntax->r.p);
                syntax->r.p = NULL;
                syntax->type = YST_KINT;
                syntax->v.i = val;
            }
        }
        break;
    };

    return 0;
}

void ekCompileOptimize(struct ekContext *E, ekCompiler *compiler)
{
    ekCompileOptimizeChild(E, compiler, compiler->root);
}

// ---------------------------------------------------------------------------

enum
{
    ASM_NORMAL     = 0,
    ASM_LVALUE     = (1 << 0),
    ASM_VAR        = (1 << 1),
    ASM_SETVAR     = (1 << 2),
    ASM_LEAVE_LAST = (1 << 3)
};

#define asmFunc(NAME) \
    ekS32 ekAssemble ## NAME (struct ekContext *E, ekCompiler *compiler, ekCode *dst, ekSyntax *syntax, ekS32 keep, ekU32 flags)
typedef ekS32(*ekAssembleFunc)(struct ekContext *E, ekCompiler *compiler, ekCode *dst, ekSyntax *syntax, ekS32 keep, ekU32 flags);

typedef struct ekAssembleInfo
{
    ekAssembleFunc assemble;
} ekAssembleInfo;

asmFunc(Nop);
asmFunc(KString);
asmFunc(KInt);
asmFunc(KFloat);
asmFunc(Identifier);
asmFunc(Index);
asmFunc(StatementExpr);
asmFunc(StatementList);
asmFunc(ExpressionList);
asmFunc(IdentifierList);
asmFunc(Call);
asmFunc(Null);
asmFunc(This);
asmFunc(StringFormat);
asmFunc(Unary);
asmFunc(Binary);
asmFunc(ShortCircuit);
asmFunc(Var);
asmFunc(Break);
asmFunc(Return);
asmFunc(Assignment);
asmFunc(Inherits);
asmFunc(IfElse);
asmFunc(While);
asmFunc(For);
asmFunc(Function);
asmFunc(FunctionArgs);
asmFunc(With);
asmFunc(Scope);

static ekAssembleInfo asmDispatch[YST_COUNT] =
{
    { ekAssembleNop },             // YST_NOP

    { ekAssembleKString },         // YST_KSTRING
    { ekAssembleKInt },            // YST_KINT
    { ekAssembleKFloat },          // YST_KFLOAT
    { ekAssembleIdentifier },      // YST_IDENTIFIER

    { ekAssembleIndex },           // YST_INDEX

    { ekAssembleStatementList },   // YST_STATEMENTLIST
    { ekAssembleExpressionList },  // YST_EXPRESSIONLIST
    { ekAssembleIdentifierList },  // YST_IDENTIFIERLIST

    { ekAssembleCall },            // YST_CALL
    { ekAssembleStringFormat },    // YST_STRINGFORMAT

    { ekAssembleNull },            // YST_NULL
    { ekAssembleThis },            // YST_THIS

    { ekAssembleUnary },           // YST_NOT

    { ekAssembleUnary },           // YST_BITWISE_NOT
    { ekAssembleBinary },          // YST_BITWISE_XOR
    { ekAssembleBinary },          // YST_BITWISE_AND
    { ekAssembleBinary },          // YST_BITWISE_OR
    { ekAssembleBinary },          // YST_SHIFTLEFT
    { ekAssembleBinary },          // YST_SHIFTRIGHT

    { ekAssembleBinary },          // YST_ADD
    { ekAssembleBinary },          // YST_SUB
    { ekAssembleBinary },          // YST_MUL
    { ekAssembleBinary },          // YST_DIV

    { ekAssembleShortCircuit },    // YST_AND
    { ekAssembleShortCircuit },    // YST_OR

    { ekAssembleBinary },          // YST_CMP
    { ekAssembleBinary },          // YST_EQUALS
    { ekAssembleBinary },          // YST_NOTEQUALS
    { ekAssembleBinary },          // YST_GREATERTHAN
    { ekAssembleBinary },          // YST_GREATERTHANOREQUAL
    { ekAssembleBinary },          // YST_LESSTHAN
    { ekAssembleBinary },          // YST_LESSTHANOREQUAL

    { ekAssembleStatementExpr },   // YST_STATEMENT_EXPR
    { ekAssembleAssignment },      // YST_ASSIGNMENT
    { ekAssembleInherits },        // YST_INHERITS
    { ekAssembleBreak },           // YST_BREAK
    { ekAssembleReturn },          // YST_RETURN

    { ekAssembleIfElse },          // YST_IFELSE
    { ekAssembleWhile },           // YST_WHILE
    { ekAssembleFor },             // YST_FOR
    { ekAssembleFunction },        // YST_FUNCTION
    { ekAssembleFunctionArgs },    // YST_FUNCTION_ARGS
    { ekAssembleScope },           // YST_SCOPE
};

// This function ensures that what we're being asked to keep is what we offered
int asmPad(struct ekContext *E, ekCode *code, int keep, int offer, int line)
{
    if(keep == YAV_ALL_ARGS)
    {
        keep = offer;
    }
    else
    {
        if(offer > keep)
        {
            ekCodeGrow(E, code, 1);
            ekCodeAppend(E, code, YOP_POP, (ekOperand)(offer - keep), line);
        }
        else if(offer < keep)
        {
            int i;
            int nulls = keep - offer;
            ekCodeGrow(E, code, nulls);
            for(i = 0; i < nulls; i++)
            {
                ekCodeAppend(E, code, YOP_PUSHNULL, 0, line);
            }
        }
    }
    return keep;
}

#define PAD(OFFER) asmPad(E, dst, keep, OFFER, syntax->line)

asmFunc(Nop)
{
    printf("NOP detected: %d\n", syntax->type);
    return PAD(0);
}

asmFunc(KString)
{
    ekCodeGrow(E, dst, 1);
    ekCodeAppend(E, dst, YOP_PUSH_KS, ekArrayPushUniqueString(E, &compiler->chunk->kStrings, ekStrdup(E, syntax->v.s)), syntax->line);
    return PAD(1);
}

asmFunc(KInt)
{
    ekCodeGrow(E, dst, 1);
    ekCodeAppend(E, dst, YOP_PUSH_KI, ek32ArrayPushUnique(E, &compiler->chunk->kInts, &syntax->v.i), syntax->line);
    return PAD(1);
}

asmFunc(KFloat)
{
    ekCodeGrow(E, dst, 1);
    ekCodeAppend(E, dst, YOP_PUSH_KF, ek32ArrayPushUnique(E, &compiler->chunk->kFloats, (ekU32 *)&syntax->v.f), syntax->line);
    return PAD(1);
}

asmFunc(Identifier)
{
    ekOpcode opcode = YOP_VARREF_KS;
    if(flags & ASM_VAR)
    {
        opcode = YOP_VARREG_KS;
    }
    ekCodeGrow(E, dst, 1);
    ekCodeAppend(E, dst, opcode, ekArrayPushUniqueString(E, &compiler->chunk->kStrings, ekStrdup(E, syntax->v.s)), syntax->line);
    if(!(flags & ASM_LVALUE))
    {
        ekCodeGrow(E, dst, 1);
        ekCodeAppend(E, dst, YOP_REFVAL, 0, syntax->line);
    }
    return PAD(1);
}

asmFunc(Index)
{
    ekS32 offerCount = 1;
    ekOperand opFlags = 0;
    ekBool pushThis = (syntax->v.i) ? ekTrue : ekFalse;
    ekSyntax *a = syntax->l.p;
    ekSyntax *b = syntax->r.p;
    asmDispatch[a->type].assemble(E, compiler, dst, a, 1, ASM_NORMAL);
    asmDispatch[b->type].assemble(E, compiler, dst, b, 1, ASM_NORMAL);
    if(flags & ASM_LVALUE)
    {
        opFlags |= YOF_LVALUE;
    }
    if(keep > 1)
    {
        opFlags |= (pushThis) ? YOF_PUSHTHIS : YOF_PUSHOBJ;
        offerCount++;
    }
    ekCodeGrow(E, dst, 1);
    ekCodeAppend(E, dst, YOP_INDEX, opFlags, syntax->line);
    return PAD(offerCount);
}

asmFunc(IdentifierList)
{
    ekSyntax **args = syntax->v.a;
    int additionalFlags = (syntax->v.i) ? ASM_VAR : 0;
    int keepCount = 0;
    int i;

    for(i = ekArraySize(E, &args) - 1; i >= 0; i--)
    {
        ekSyntax *arg = (ekSyntax *)args[i];
        keepCount = asmDispatch[arg->type].assemble(E, compiler, dst, arg, 1, flags | additionalFlags);
        if(flags & ASM_SETVAR)
        {
            ekCodeGrow(E, dst, 1);
            ekCodeAppend(E, dst, YOP_SETVAR, ((flags & ASM_LEAVE_LAST) && !i) ? 1 : 0, syntax->line);
        }
    }
    return PAD(ekArraySize(E, &args));
}

asmFunc(Call)
{
    ekSyntax *func = syntax->v.p;
    ekSyntax *args = syntax->r.p;
    int argCount;
    int retCount;

    argCount = asmDispatch[args->type].assemble(E, compiler, dst, args, YAV_ALL_ARGS, ASM_NORMAL);
    retCount = asmDispatch[func->type].assemble(E, compiler, dst, func, 2, ASM_NORMAL); // requesting 2 to receive 'this' (even if padded with null)

    if(keep == YAV_ALL_ARGS)
    {
        keep = retCount;
    }

    ekCodeGrow(E, dst, 2);
    ekCodeAppend(E, dst, YOP_CALL, argCount, syntax->line);
    ekCodeAppend(E, dst, YOP_KEEP, keep, syntax->line);
    return PAD(keep);
}

asmFunc(Null)
{
    ekCodeGrow(E, dst, 1);
    ekCodeAppend(E, dst, YOP_PUSHNULL, 0, syntax->line);
    return PAD(1);
}

asmFunc(This)
{
    ekCodeGrow(E, dst, 1);
    ekCodeAppend(E, dst, YOP_PUSHTHIS, 0, syntax->line);
    return PAD(1);
}

asmFunc(StringFormat)
{
    ekSyntax *format = syntax->l.p;
    ekSyntax *args   = syntax->r.p;
    int argCount = asmDispatch[args->type].assemble(E, compiler, dst, args, YAV_ALL_ARGS, ASM_NORMAL);
    asmDispatch[format->type].assemble(E, compiler, dst, format, 1, ASM_NORMAL);
    ekCodeGrow(E, dst, 1);
    ekCodeAppend(E, dst, YOP_FORMAT, argCount, syntax->line);
    return PAD(1);
}

asmFunc(Unary)
{
    ekSyntax *expr = syntax->v.p;
    asmDispatch[expr->type].assemble(E, compiler, dst, expr, 1, ASM_NORMAL);
    ekCodeGrow(E, dst, 1);
    switch(syntax->type)
    {
        case YST_NOT:
            ekCodeAppend(E, dst, YOP_NOT, 0, syntax->line);
            break;
        case YST_BITWISE_NOT:
            ekCodeAppend(E, dst, YOP_BITWISE_NOT, 0, syntax->line);
            break;
    };
    return PAD(1);
}

asmFunc(Binary)
{
    ekSyntax *a = syntax->l.p;
    ekSyntax *b = syntax->r.p;
    ekBool compound = syntax->v.i;
    int op = YOP_NOP;
    int aflags = ASM_NORMAL;

    if(compound)
    {
        aflags = ASM_LVALUE;
    }

    asmDispatch[a->type].assemble(E, compiler, dst, a, 1, aflags);
    if(compound)
    {
        ekCodeGrow(E, dst, 2);
        ekCodeAppend(E, dst, YOP_DUPE, 0, syntax->line);
        ekCodeAppend(E, dst, YOP_REFVAL, 0, syntax->line);
    }
    asmDispatch[b->type].assemble(E, compiler, dst, b, 1, ASM_NORMAL);

    switch(syntax->type)
    {
            // Legal in either compound statements or expressions
        case YST_ADD:
            op = YOP_ADD;
            break;
        case YST_SUB:
            op = YOP_SUB;
            break;
        case YST_MUL:
            op = YOP_MUL;
            break;
        case YST_DIV:
            op = YOP_DIV;
            break;
        case YST_BITWISE_XOR:
            op = YOP_BITWISE_XOR;
            break;
        case YST_BITWISE_AND:
            op = YOP_BITWISE_AND;
            break;
        case YST_BITWISE_OR:
            op = YOP_BITWISE_OR;
            break;
        case YST_SHIFTLEFT:
            op = YOP_SHIFTLEFT;
            break;
        case YST_SHIFTRIGHT:
            op = YOP_SHIFTRIGHT;
            break;

            // Legal in expressions only
        case YST_CMP:
            op = YOP_CMP;
            break;
        case YST_EQUALS:
            op = YOP_EQUALS;
            break;
        case YST_NOTEQUALS:
            op = YOP_NOTEQUALS;
            break;
        case YST_GREATERTHAN:
            op = YOP_GREATERTHAN;
            break;
        case YST_GREATERTHANOREQUAL:
            op = YOP_GREATERTHANOREQUAL;
            break;
        case YST_LESSTHAN:
            op = YOP_LESSTHAN;
            break;
        case YST_LESSTHANOREQUAL:
            op = YOP_LESSTHANOREQUAL;
            break;
    };

    ekCodeGrow(E, dst, 1);
    ekCodeAppend(E, dst, op, 0, syntax->line);

    if(compound)
    {
        ekCodeGrow(E, dst, 2);
        ekCodeAppend(E, dst, YOP_MOVE, 1, syntax->line);
        ekCodeAppend(E, dst, YOP_SETVAR, 0, syntax->line);
        return PAD(0);
    }
    return PAD(1);
}

asmFunc(ShortCircuit)
{
    ekS32 skipIndex;
    ekSyntax *a = syntax->l.p;
    ekSyntax *b = syntax->r.p;

    // code to add first expression on the stack
    asmDispatch[a->type].assemble(E, compiler, dst, a, 1, ASM_NORMAL);

    // test stack top's truth and uses the current value instead of the second expression's value
    ekCodeGrow(E, dst, 1);
    skipIndex = ekCodeAppend(E, dst, (syntax->type == YST_AND) ? YOP_AND : YOP_OR, 0, syntax->line);

    // code to add second expression on the stack
    asmDispatch[b->type].assemble(E, compiler, dst, b, 1, ASM_NORMAL);

    // clue in the and/or opcode how far to optionally jump
    dst->ops[skipIndex].operand = dst->count - skipIndex - 1;

    return PAD(1);
}

asmFunc(Break)
{
    ekCodeGrow(E, dst, 1);
    ekCodeAppend(E, dst, YOP_BREAK, 0, syntax->line);
    return PAD(0);
}

asmFunc(Return)
{
    ekSyntax *expr = syntax->v.p;
    int retCount = asmDispatch[expr->type].assemble(E, compiler, dst, expr, YAV_ALL_ARGS, ASM_NORMAL);
    ekCodeGrow(E, dst, 1);
    ekCodeAppend(E, dst, YOP_RET, retCount, syntax->line);
    return PAD(0);
}

asmFunc(Assignment)
{
    int i;
    ekSyntax *l = syntax->l.p;
    ekSyntax *r = syntax->r.p;
    int leave = (keep > 0) ? 1 : 0;
    int lflags = ASM_LVALUE|ASM_SETVAR | ((leave) ? ASM_LEAVE_LAST : 0);
    ekCode *lvalueCode = ekCodeCreate();
    int lvalueCount = asmDispatch[l->type].assemble(E, compiler, lvalueCode, l, YAV_ALL_ARGS, lflags);
    asmDispatch[r->type].assemble(E, compiler, dst, r, lvalueCount, ASM_NORMAL);
    ekCodeConcat(E, dst, lvalueCode);
    ekCodeDestroy(E, lvalueCode);
    if((l->type != YST_IDENTIFIERLIST) && (l->type != YST_EXPRESSIONLIST))
    {
        ekCodeGrow(E, dst, 1);
        ekCodeAppend(E, dst, YOP_SETVAR, leave, syntax->line);
    }
    return PAD(leave);
}

asmFunc(Inherits)
{
    ekSyntax *l = syntax->l.p;
    ekSyntax *r = syntax->r.p;

    asmDispatch[r->type].assemble(E, compiler, dst, r, 1, ASM_NORMAL);
    asmDispatch[l->type].assemble(E, compiler, dst, l, 1, ASM_NORMAL);
    ekCodeGrow(E, dst, 1);
    ekCodeAppend(E, dst, YOP_INHERITS, 0, syntax->line);
    return PAD(1);
}

asmFunc(IfElse)
{
    ekBool      ternary  = syntax->v.i;
    ekSyntax *cond     = syntax->v.p;
    ekSyntax *ifBody   = syntax->l.p;
    ekSyntax *elseBody = syntax->r.p;
    ekCode *ifCode = ekCodeCreate();
    int index;
    int i;
    int valuesLeftOnStack = (ternary) ? 1 : 0;

    if(elseBody)
    {
        ekCode *elseCode = ekCodeCreate();
        asmDispatch[elseBody->type].assemble(E, compiler, elseCode, elseBody, valuesLeftOnStack, ASM_NORMAL);
        ekCodeGrow(E, elseCode, 1);
        ekCodeAppend(E, elseCode, YOP_LEAVE, 0, syntax->line);
        index = ekBlockConvertCode(E, elseCode, compiler->chunk, 0);
        ekCodeGrow(E, dst, 1);
        ekCodeAppend(E, dst, YOP_PUSH_KB, index, syntax->line);
    }

    asmDispatch[ifBody->type].assemble(E, compiler, ifCode, ifBody, valuesLeftOnStack, ASM_NORMAL);
    ekCodeGrow(E, ifCode, 1);
    ekCodeAppend(E, ifCode, YOP_LEAVE, 0, syntax->line);
    index = ekBlockConvertCode(E, ifCode, compiler->chunk, 0);
    ekCodeGrow(E, dst, 1);
    ekCodeAppend(E, dst, YOP_PUSH_KB, index, syntax->line);

    // Only keeps the value of the first expression on the stack for bool testing
    asmDispatch[cond->type].assemble(E, compiler, dst, cond, 1, ASM_NORMAL);

    ekCodeGrow(E, dst, 1);
    ekCodeAppend(E, dst, YOP_IF, (elseBody) ? 1 : 0, syntax->line);

    return PAD(valuesLeftOnStack);
}

asmFunc(While)
{
    ekSyntax *cond = syntax->v.p;
    ekSyntax *body = syntax->r.p;
    ekCode   *loop = ekCodeCreate();
    int index;

    ekCodeGrow(E, loop, 1);
    ekCodeAppend(E, loop, YOP_START, 0, syntax->line);

    asmDispatch[cond->type].assemble(E, compiler, loop, cond, 1, ASM_NORMAL);
    ekCodeGrow(E, loop, 1);
    ekCodeAppend(E, loop, YOP_LEAVE, 1, syntax->line);

    asmDispatch[body->type].assemble(E, compiler, loop, body, 0, ASM_NORMAL);

    ekCodeGrow(E, loop, 1);
    ekCodeAppend(E, loop, YOP_CONTINUE, 0, syntax->line);

    index = ekBlockConvertCode(E, loop, compiler->chunk, 0);

    ekCodeGrow(E, dst, 1);
    ekCodeAppend(E, dst, YOP_PUSH_KB, index, syntax->line);
    ekCodeGrow(E, dst, 1);
    ekCodeAppend(E, dst, YOP_ENTER, YFT_LOOP, syntax->line);

    return PAD(0);
}

asmFunc(For)
{
    ekSyntax *vars = syntax->v.p;
    ekSyntax *iter = syntax->l.p;
    ekSyntax *body = syntax->r.p;
    ekCode   *loop = ekCodeCreate();
    int index;

    // Get the iterable onto the stack
    asmDispatch[iter->type].assemble(E, compiler, dst, iter, 1, ASM_NORMAL);

    ekCodeGrow(E, loop, 5);
    ekCodeAppend(E, loop, YOP_DUPE, 0, syntax->line);    // stash the object itself
    ekCodeAppend(E, loop, YOP_COUNT, 0, syntax->line);   // using the dupe, call .count(, syntax->line) to push the count on top
    ekCodeAppend(E, loop, YOP_KEEP, 1, syntax->line);    // keep only one value from the call to .count()
    ekCodeAppend(E, loop, YOP_PUSHI, 0, syntax->line);   // init our counter to zero
    ekCodeAppend(E, loop, YOP_CLEANUP, 3, syntax->line); // Mark the 3 'for loop' items as things to clean up

    // At this point, the stack should look like:
    // -- top --
    // counter = 0
    // count = N
    // object

    ekCodeGrow(E, loop, 3);
    ekCodeAppend(E, loop, YOP_START, 0, syntax->line);   // begin loop
    ekCodeAppend(E, loop, YOP_SUB, 1, syntax->line);     // push (count-counter, syntax->line) onto stack
    ekCodeAppend(E, loop, YOP_LEAVE, 1, syntax->line);   // leave if ((count-counter, syntax->line) == 0)

    // Populate the loop vars from the call to get()
    ekCodeGrow(E, loop, 7);
    ekCodeAppend(E, loop, YOP_DUPE, 0, syntax->line);    // dupe counter
    ekCodeAppend(E, loop, YOP_DUPE, 3, syntax->line);    // dupe object
    ekCodeAppend(E, loop, YOP_NTH, 0, syntax->line);     // call nth
    ekCodeAppend(E, loop, YOP_KEEP, ekArraySize(E, &vars->v.a), syntax->line);
    asmDispatch[vars->type].assemble(E, compiler, loop, vars, ekArraySize(E, &vars->v.a), ASM_LVALUE | ASM_VAR);

    // Assemble the loop body itself
    asmDispatch[body->type].assemble(E, compiler, loop, body, 0, ASM_NORMAL);

    // Increment the counter and loop
    ekCodeGrow(E, loop, 3);
    ekCodeAppend(E, loop, YOP_PUSHI, 1, syntax->line);
    ekCodeAppend(E, loop, YOP_ADD, 0, syntax->line);
    ekCodeAppend(E, loop, YOP_CONTINUE, 0, syntax->line);

    index = ekBlockConvertCode(E, loop, compiler->chunk, 0);

    ekCodeGrow(E, dst, 2);
    ekCodeAppend(E, dst, YOP_PUSH_KB, index, syntax->line);
    ekCodeAppend(E, dst, YOP_ENTER, YFT_LOOP, syntax->line);

    return PAD(0);
}

asmFunc(Function)
{
    ekSyntax *args = syntax->l.p;
    ekSyntax *body = syntax->r.p;
    char *name = syntax->v.s;
    ekCode *code = ekCodeCreate();
    ekOperand index;

    // If a name is used ("func name()" vs "func()"), the
    // generated code will consume the block left on the stack
    // with a setvar, effectively compiling "func name()" into
    // "var name = func()".
    int additionalOpsForNaming = 0;
    int valuesLeftOnStack = 1;

    int argCount = asmDispatch[args->type].assemble(E, compiler, code, args, YAV_ALL_ARGS, ASM_VAR | ASM_LVALUE | ASM_SETVAR);
    asmDispatch[body->type].assemble(E, compiler, code, body, 0, ASM_NORMAL);
    ekCodeGrow(E, code, 1);
    ekCodeAppend(E, code, YOP_RET, 0, syntax->line);
    index = ekBlockConvertCode(E, code, compiler->chunk, argCount);

    if(name)
    {
        additionalOpsForNaming = 2;
        valuesLeftOnStack = 0;
    }
    ekCodeGrow(E, dst, 2 + additionalOpsForNaming);
    ekCodeAppend(E, dst, YOP_PUSH_KB, index, syntax->line);    // Push the new block on the stack
    ekCodeAppend(E, dst, YOP_CLOSE, 0, syntax->line);          // Give the VM an opportunity to pepper it with closure data
    if(name)
    {
        ekCodeAppend(E, dst, YOP_VARREG_KS, ekArrayPushUniqueString(E, &compiler->chunk->kStrings, ekStrdup(E, name)), syntax->line);
        ekCodeAppend(E, dst, YOP_SETVAR, 0, syntax->line);
    };
    compiler->chunk->hasFuncs = ekTrue;
    return PAD(valuesLeftOnStack);
}

asmFunc(FunctionArgs)
{
    int argCount;
    int varargsOpIndex = 0;
    ekSyntax *args = syntax->l.p;
    const char *varargsName = syntax->v.s;
    if(varargsName)
    {
        ekCodeGrow(E, dst, 3);
        varargsOpIndex = ekCodeAppend(E, dst, YOP_VARARGS, 0, args->line);
        ekCodeAppend(E, dst, YOP_VARREG_KS, ekArrayPushUniqueString(E, &compiler->chunk->kStrings, ekStrdup(E, varargsName)), syntax->line);
        ekCodeAppend(E, dst, YOP_SETVAR, 0, syntax->line);
    }

    argCount = asmDispatch[args->type].assemble(E, compiler, dst, args, keep, flags);

    if(varargsName)
    {
        dst->ops[varargsOpIndex].operand = argCount;
        return YAV_ALL_ARGS;
    }
    return argCount;
}

asmFunc(Scope)
{
    ekSyntax *body = syntax->v.p;
    ekCode   *code = ekCodeCreate();
    int index;

    // create new block from "body"
    asmDispatch[body->type].assemble(E, compiler, code, body, 0, ASM_NORMAL);
    ekCodeGrow(E, code, 1);
    ekCodeAppend(E, code, YOP_LEAVE, 0, syntax->line);
    index = ekBlockConvertCode(E, code, compiler->chunk, 0);

    ekCodeGrow(E, dst, 1);
    ekCodeAppend(E, dst, YOP_PUSH_KB, index, syntax->line);
    ekCodeGrow(E, dst, 1);
    ekCodeAppend(E, dst, YOP_ENTER, YFT_SCOPE, syntax->line);

    return PAD(0);
}

asmFunc(ExpressionList)
{
    int i = 0;
    int last = ekArraySize(E, &syntax->v.a);
    int increment = 1;
    int keepCount = 0;
    int reverseOrder = (flags & ASM_SETVAR); // values must be SETVAR'd by popping off the stack in reverse
    for(i = 0; i < ekArraySize(E, &syntax->v.a); i++)
    {
        int index = (reverseOrder) ? (ekArraySize(E, &syntax->v.a) - 1) - i : i;
        int keepIt = ((keep == YAV_ALL_ARGS) || (i < keep)) ? 1 : 0; // keep one from each expr, dump the rest
        ekSyntax *child = syntax->v.a[index];
        keepCount += asmDispatch[child->type].assemble(E, compiler, dst, child, keepIt, flags & ~ASM_SETVAR);
        if(flags & ASM_SETVAR)
        {
            ekCodeGrow(E, dst, 1);
            ekCodeAppend(E, dst, YOP_SETVAR, ((flags & ASM_LEAVE_LAST) && (i != ekArraySize(E, &syntax->v.a)-1)) ? 1 : 0, syntax->line);
        }
    }
    return PAD(keepCount);
}

asmFunc(StatementExpr)
{
    ekSyntax *child = syntax->v.p;
    int keepCount = asmDispatch[child->type].assemble(E, compiler, dst, child, keep, ASM_NORMAL);
    return PAD(keepCount);
}

asmFunc(StatementList)
{
    int keepCount = 0;
    int i;
    for(i = 0; i < ekArraySize(E, &syntax->v.a); i++)
    {
        ekSyntax *child = syntax->v.a[i];
        keepCount = asmDispatch[child->type].assemble(E, compiler, dst, child, 0, ASM_NORMAL);
    }
    return PAD(keepCount);
}

ekBool ekAssemble(struct ekContext *E, ekCompiler *compiler)
{
    if(compiler->root && (compiler->root->type == YST_STATEMENTLIST))
    {
        int blockIndex;
        compiler->chunk = ekChunkCreate();
        compiler->code   = ekCodeCreate();
        ekAssembleStatementList(E, compiler, compiler->code, compiler->root, 0, ASM_NORMAL);
        ekCodeGrow(E, compiler->code, 1);
        ekCodeAppend(E, compiler->code, YOP_RET, 0, 0);
        blockIndex = ekBlockConvertCode(E, compiler->code, compiler->chunk, 0);
        compiler->chunk->block = compiler->chunk->blocks[blockIndex];
    }
    return ekTrue;
}
